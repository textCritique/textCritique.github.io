---
layout: post
title: Python
date: 2025-12-31 22:33 +0530
description:
image:
category: [notes, python]
tags: [python]
author: textCritique
published: false
sitemap: true
---

This will contain random notes about python programming language.

# Random tips and tricks

### Unpacking values

In python you can unpack values from lists, tuples, etc. like this

```python
a, b = [1, 2]
print(a)  # Output: 1
print(b)  # Output: 2
```
But if the number of variables on the left does not match the number of elements on the right, it will raise a `ValueError`.
```python
a, b = [1, 2, 3]  # Raises ValueError: too many values to unpack (expected 2)
```

But you can use the `*` operator to capture excess values into a list:
```python
a, *b = [1, 2, 3, 4]
print(a)  # Output: 1
print(b)  # Output: [2, 3, 4]
```

### Type hints

To specify that a variable is expected to be of a certain type, you can use type hints:
```python
def greet(name: str) -> str:
    return "Hello, " + name
```
It means that the `name` parameter is expected to be a string, and the function will return a string. Note that type hints are not enforced at runtime; they are mainly for documentation and static analysis tools.

When definition of class is not complete and you want one of its method to return instance of same class, you can use string literal for type hinting.

(note to myself : better example needed which is short yet meaningful)
```python
class Product:
    def get_self(self) -> "Product":
        return self
```

### padding numbers with leading zeros

You can use f strings to pad numbers with leading zeros:
```python
n = 10
padded = f"{n:03}"
print(padded)  # Output: 010
```
This will pad the number `n` with leading zeros to make it at least 3 digits long.

Similarly you can use it for floating point numbers:
```python
pi = 3.14159
padded_pi = f"{pi:07.3f}"
print(padded_pi)  # Output: 003.142
```
This will pad the floating point number `pi` with leading zeros to make it at least 7 characters long, including 3 digits after the decimal point. Also note that it rounds the number to 3 decimal places, instead of truncating it.

### making user defined objects iterable

To make a user-defined object iterable, you need to implement the `__iter__()` and `__next__()` methods in your class. Here's an example of a simple iterable class that generates a sequence of numbers:

```python
# simple book class
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def __str__(self):
        return f"'{self.title}' by {self.author}"

# main iterable class
class Bookshelf:
    def __init__(self):
        self.books = []
        
    def add_book(self, book):
        self.books.append(book)

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self.books):
            book = self.books[self.index]
            self.index += 1
            return book
        else:
            raise StopIteration

    def __str__(self):
        return f"Bookshelf with {len(self.books)} books"

```
```python
# Example usage
shelf = Bookshelf()
shelf.add_book(Book("1Q84", "Haruki Murakami"))
shelf.add_book(Book("Kafka on the Shore", "Haruki Murakami"))
shelf.add_book(Book("Beauty and Sadness", "Yasunari Kawabata"))
for book in shelf:
    print(book)
```
```
'1Q84' by Haruki Murakami
'Kafka on the Shore' by Haruki Murakami
'Beauty and Sadness' by Yasunari Kawabata
```

## design patterns in oops

### singleton pattern
The singleton pattern ensures that a class has only one instance and provides a global point of access to it. Here's an example of how to implement the singleton pattern in Python using a decorator:

```python
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance
@singleton
class DatabaseConnection:
    def __init__(self):
        self.connection = self.connect_to_database()
    def connect_to_database(self):
        # Simulate a database connection
        return "Database connection established"
# Example usage
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(db1 is db2)  # Output: True
```
In this example, the `singleton` decorator ensures that only one instance of the `DatabaseConnection` class is created. When you try to create multiple instances, it returns the same instance.
### factory pattern
The factory pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. Here's an example of how to implement the factory pattern in Python:
```python
class Dog:
    def speak(self):
        return "Woof!"
class Cat:
    def speak(self):
        return "Meow!"
class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError("Unknown animal type")
# Example usage
dog = AnimalFactory.create_animal("dog")
cat = AnimalFactory.create_animal("cat")
print(dog.speak())  # Output: Woof!
print(cat.speak())  # Output: Meow!
```
In this example, the `AnimalFactory` class has a static method `create_animal` that takes an `animal_type` parameter and returns an instance of the corresponding animal class (`Dog` or `Cat`). This allows for easy creation of different types of animals without needing to know the details of their instantiation.

### observer pattern
The observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Here's an example of how to implement the observer pattern in Python:
```python
class Subject:
    def __init__(self):
        self._observers = []
    def attach(self, observer):
        self._observers.append(observer)
    def detach(self, observer):
        self._observers.remove(observer)
    def notify(self, message):
        for observer in self._observers:
            observer.update(message)
class Observer:
    def update(self, message):
        pass
class ConcreteObserver(Observer):
    def __init__(self, name):
        self.name = name
    def update(self, message):
        print(f"{self.name} received message: {message}")
# Example usage
subject = Subject()
observer1 = ConcreteObserver("Observer 1")
observer2 = ConcreteObserver("Observer 2")
subject.attach(observer1)
subject.attach(observer2)
subject.notify("Hello Observers!")
```
```Observer 1 received message: Hello Observers!
Observer 2 received message: Hello Observers!
```
In this example, the `Subject` class maintains a list of observers and provides methods to attach, detach, and notify them. The `ConcreteObserver` class implements the `update` method to handle notifications from the subject. When the subject's state changes, it calls the `notify` method to inform all attached observers.

### decorator pattern

The decorator pattern allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class. Here's an example of how to implement the decorator pattern in Python:
```python
def make_bold(func):
    def wrapper():
        return "<b>" + func() + "</b>"
    return wrapper

@make_bold
def greet():
    return "Hello!"
# Example usage
print(greet())  # Output: <b>Hello!</b>
```

In this example, the `make_bold` function is a decorator that adds HTML bold tags around the output of the `greet` function. When `greet` is called, it returns the string wrapped in `<b>` and `</b>` tags.

### strategy pattern

The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This allows the algorithm to vary independently from clients that use it. Here's an example of how to implement the strategy pattern in Python:
```python

class Strategy:
    def execute(self, a, b):
        pass
class Addition(Strategy):
    def execute(self, a, b):
        return a + b
class Subtraction(Strategy):
    def execute(self, a, b):
        return a - b
class Context:
    def __init__(self, strategy: Strategy):
        self._strategy = strategy
    def set_strategy(self, strategy: Strategy):
        self._strategy = strategy
    def execute_strategy(self, a, b):
        return self._strategy.execute(a, b)
# Example usage
context = Context(Addition())
print(context.execute_strategy(5, 3))  # Output: 8
context.set_strategy(Subtraction())
print(context.execute_strategy(5, 3))  # Output: 2
```
In this example, the `Strategy` class defines an interface for executing an algorithm. The `Addition` and `Subtraction` classes implement this interface with specific algorithms. The `Context` class uses a `Strategy` object to execute the algorithm, allowing the strategy to be changed at runtime.
